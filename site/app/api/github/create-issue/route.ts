import { NextRequest, NextResponse } from 'next/server';
import { createGitHubClient, parseRepoFullName } from '@/lib/github-client';
import { verifySessionToken } from '@/lib/auth';

/**
 * Create GitHub Issue with Code Review Findings
 * POST /api/github/create-issue
 *
 * Body:
 * {
 *   repoFullName: "owner/repo",
 *   title: "AutoRev Code Review - 2025-10-20",
 *   findings: [
 *     { severity: "critical", file: "src/app.ts", line: 42, message: "...", recommendation: "..." }
 *   ]
 * }
 */
export async function POST(request: NextRequest) {
  try {
    // Verify authentication
    const sessionToken = request.cookies.get('session')?.value;
    if (!sessionToken) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const session = verifySessionToken(sessionToken);
    if (!session) {
      return NextResponse.json({ error: 'Invalid session' }, { status: 401 });
    }

    // Parse request body
    const body = await request.json();
    const { repoFullName, title, findings } = body;

    if (!repoFullName || !title || !findings || !Array.isArray(findings)) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    const { owner, repo } = parseRepoFullName(repoFullName);

    // Create GitHub client
    const github = createGitHubClient(session.accessToken);

    // Format issue body with findings
    const issueBody = formatCodeReviewIssue(findings);

    // Create issue
    const issue = await github.createIssue(
      owner,
      repo,
      title,
      issueBody,
      ['code-review', 'autorev', 'automated']
    );

    return NextResponse.json({
      success: true,
      issue: {
        number: issue.number,
        url: issue.html_url,
        title: issue.title,
      },
    });
  } catch (error: any) {
    console.error('Error creating GitHub issue:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create issue' },
      { status: 500 }
    );
  }
}

/**
 * Format code review findings as GitHub issue markdown
 */
function formatCodeReviewIssue(findings: any[]): string {
  const timestamp = new Date().toISOString();

  let markdown = `# AutoRev Code Review Report\n\n`;
  markdown += `**Generated**: ${new Date(timestamp).toLocaleString()}\n`;
  markdown += `**Total Findings**: ${findings.length}\n\n`;

  // Group by severity
  const bySeverity: Record<string, any[]> = {};
  findings.forEach((finding) => {
    const severity = finding.severity || 'info';
    if (!bySeverity[severity]) {
      bySeverity[severity] = [];
    }
    bySeverity[severity].push(finding);
  });

  // Summary section
  markdown += `## Summary\n\n`;
  markdown += `| Severity | Count |\n`;
  markdown += `|----------|-------|\n`;
  Object.entries(bySeverity)
    .sort(([a], [b]) => severityOrder(b) - severityOrder(a))
    .forEach(([severity, items]) => {
      const icon = getSeverityIcon(severity);
      markdown += `| ${icon} ${severity.toUpperCase()} | ${items.length} |\n`;
    });
  markdown += `\n`;

  // Detailed findings by severity
  ['critical', 'high', 'medium', 'low', 'info'].forEach((severity) => {
    const items = bySeverity[severity];
    if (!items || items.length === 0) return;

    const icon = getSeverityIcon(severity);
    markdown += `## ${icon} ${severity.toUpperCase()} Severity\n\n`;

    items.forEach((finding, index) => {
      markdown += `### ${index + 1}. ${finding.message}\n\n`;
      markdown += `**File**: \`${finding.file}\` (Line ${finding.line})\n\n`;

      if (finding.recommendation) {
        markdown += `**Recommendation**:\n${finding.recommendation}\n\n`;
      }

      if (finding.code) {
        markdown += `**Code**:\n\`\`\`\n${finding.code}\n\`\`\`\n\n`;
      }

      markdown += `---\n\n`;
    });
  });

  // Footer
  markdown += `\n---\n`;
  markdown += `*This issue was automatically generated by [AutoRev Code Review](https://autorev.servicevision.io)*\n`;

  return markdown;
}

function getSeverityIcon(severity: string): string {
  const icons: Record<string, string> = {
    critical: 'ðŸ”´',
    high: 'ðŸŸ ',
    medium: 'ðŸŸ¡',
    low: 'ðŸ”µ',
    info: 'âšª',
  };
  return icons[severity.toLowerCase()] || 'âšª';
}

function severityOrder(severity: string): number {
  const order: Record<string, number> = {
    critical: 5,
    high: 4,
    medium: 3,
    low: 2,
    info: 1,
  };
  return order[severity.toLowerCase()] || 0;
}
