import { NextRequest, NextResponse } from 'next/server';
import { createGitHubClient, parseRepoFullName } from '@/lib/github-client';
import { verifySessionToken } from '@/lib/auth';

/**
 * Create Pull Request with Code Review Report File
 * POST /api/github/create-review-pr
 *
 * This creates a PR that adds a markdown file with the code review report to the repository.
 * The file is added to a `.autorev/` directory at the root of the repo.
 *
 * Body:
 * {
 *   repoFullName: "owner/repo",
 *   baseBranch: "main",
 *   findings: [...],
 *   analysisId: "uuid"
 * }
 */
export async function POST(request: NextRequest) {
  try {
    // Verify authentication
    const sessionToken = request.cookies.get('session')?.value;
    if (!sessionToken) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const session = verifySessionToken(sessionToken);
    if (!session) {
      return NextResponse.json({ error: 'Invalid session' }, { status: 401 });
    }

    // Parse request body
    const body = await request.json();
    const { repoFullName, baseBranch = 'main', findings, analysisId } = body;

    if (!repoFullName || !findings || !Array.isArray(findings)) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    const { owner, repo } = parseRepoFullName(repoFullName);

    // Create GitHub client
    const github = createGitHubClient(session.accessToken);

    // Generate review report content
    const timestamp = new Date().toISOString().split('T')[0];
    const reportContent = generateReviewReport(findings, analysisId, timestamp);
    const reportPath = `.autorev/reviews/${timestamp}-${analysisId || 'analysis'}.md`;

    // Generate PR title and body
    const prTitle = `AutoRev Code Review Report - ${timestamp}`;
    const prBody = generatePRBody(findings, analysisId);

    try {
      // Create PR with the review file
      const result = await github.createFixPullRequest(
        owner,
        repo,
        baseBranch,
        [
          {
            path: reportPath,
            content: reportContent,
            message: `Add AutoRev code review report for ${timestamp}`,
          },
        ],
        prTitle,
        prBody
      );

      return NextResponse.json({
        success: true,
        pullRequest: {
          number: result.pr.number,
          url: result.pr.html_url,
          title: result.pr.title,
          branch: result.branchName,
        },
        reportPath,
      });
    } catch (error: any) {
      // If PR creation fails (e.g., branch protection), create the file directly
      if (error.message?.includes('protected') || error.message?.includes('permission')) {
        // Try creating an issue instead
        const issue = await github.createIssue(
          owner,
          repo,
          prTitle,
          `${prBody}\n\n---\n\n**Note**: Could not create a pull request due to branch protection rules. Please see the detailed report below.`,
          ['code-review', 'autorev', 'automated']
        );

        return NextResponse.json({
          success: true,
          fallbackToIssue: true,
          issue: {
            number: issue.number,
            url: issue.html_url,
            title: issue.title,
          },
          message:
            'Created an issue instead of PR due to branch protection or permissions.',
        });
      }

      throw error;
    }
  } catch (error: any) {
    console.error('Error creating review PR:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create review PR' },
      { status: 500 }
    );
  }
}

/**
 * Generate comprehensive code review report in markdown
 */
function generateReviewReport(
  findings: any[],
  analysisId: string | undefined,
  timestamp: string
): string {
  let report = `# AutoRev Code Review Report\n\n`;

  // Metadata
  report += `- **Date**: ${new Date(timestamp).toLocaleString()}\n`;
  report += `- **Analysis ID**: ${analysisId || 'N/A'}\n`;
  report += `- **Total Findings**: ${findings.length}\n`;
  report += `- **Generated by**: [AutoRev](https://autorev.servicevision.io)\n\n`;

  // Executive Summary
  const stats = calculateStats(findings);
  report += `## Executive Summary\n\n`;
  report += `This automated code review identified **${findings.length} findings** across your codebase.\n\n`;
  report += `### Severity Breakdown\n\n`;
  report += `| Severity | Count | Percentage |\n`;
  report += `|----------|-------|-----------|\n`;
  ['critical', 'high', 'medium', 'low', 'info'].forEach((severity) => {
    const count = stats[severity] || 0;
    const percentage = findings.length > 0 ? ((count / findings.length) * 100).toFixed(1) : '0.0';
    const icon = getSeverityIcon(severity);
    report += `| ${icon} ${severity.toUpperCase()} | ${count} | ${percentage}% |\n`;
  });
  report += `\n`;

  // Risk Assessment
  report += `### Risk Assessment\n\n`;
  if (stats.critical > 0) {
    report += `ðŸ”´ **HIGH RISK**: ${stats.critical} critical issue(s) require immediate attention.\n\n`;
  } else if (stats.high > 0) {
    report += `ðŸŸ  **MEDIUM RISK**: ${stats.high} high-severity issue(s) should be addressed soon.\n\n`;
  } else {
    report += `ðŸŸ¢ **LOW RISK**: No critical or high-severity issues detected.\n\n`;
  }

  // Detailed Findings
  report += `---\n\n## Detailed Findings\n\n`;

  ['critical', 'high', 'medium', 'low', 'info'].forEach((severity) => {
    const items = findings.filter((f) => f.severity?.toLowerCase() === severity);
    if (items.length === 0) return;

    const icon = getSeverityIcon(severity);
    report += `### ${icon} ${severity.toUpperCase()} Severity (${items.length})\n\n`;

    items.forEach((finding, index) => {
      report += `#### ${index + 1}. ${finding.message}\n\n`;
      report += `- **File**: \`${finding.file}\`\n`;
      report += `- **Line**: ${finding.line}\n`;

      if (finding.rule) {
        report += `- **Rule**: ${finding.rule}\n`;
      }

      report += `\n`;

      if (finding.recommendation) {
        report += `**Recommendation**:\n\n`;
        report += `${finding.recommendation}\n\n`;
      }

      if (finding.code) {
        report += `**Code Context**:\n\n`;
        report += `\`\`\`\n${finding.code}\n\`\`\`\n\n`;
      }

      if (finding.suggestedFix) {
        report += `**Suggested Fix**:\n\n`;
        report += `\`\`\`\n${finding.suggestedFix}\n\`\`\`\n\n`;
      }

      report += `---\n\n`;
    });
  });

  // Action Items
  report += `## Recommended Action Items\n\n`;
  if (stats.critical > 0) {
    report += `1. **ðŸ”´ Critical**: Address ${stats.critical} critical issue(s) immediately\n`;
  }
  if (stats.high > 0) {
    report += `2. **ðŸŸ  High**: Review and fix ${stats.high} high-severity issue(s) this sprint\n`;
  }
  if (stats.medium > 0) {
    report += `3. **ðŸŸ¡ Medium**: Plan fixes for ${stats.medium} medium-severity issue(s) in upcoming sprints\n`;
  }
  report += `4. **ðŸ“Š Metrics**: Track progress on remaining ${findings.length} total findings\n\n`;

  // Footer
  report += `---\n\n`;
  report += `*This report was automatically generated by AutoRev Code Review. For questions or support, visit [autorev.servicevision.io](https://autorev.servicevision.io)*\n`;

  return report;
}

/**
 * Generate PR body with summary
 */
function generatePRBody(findings: any[], analysisId: string | undefined): string {
  const stats = calculateStats(findings);

  let body = `## AutoRev Code Review Report\n\n`;
  body += `This PR adds a comprehensive code review report to your repository under \`.autorev/reviews/\`.\n\n`;

  body += `### Summary\n\n`;
  body += `- **Total Findings**: ${findings.length}\n`;
  body += `- ðŸ”´ **Critical**: ${stats.critical}\n`;
  body += `- ðŸŸ  **High**: ${stats.high}\n`;
  body += `- ðŸŸ¡ **Medium**: ${stats.medium}\n`;
  body += `- ðŸ”µ **Low**: ${stats.low}\n`;
  body += `- âšª **Info**: ${stats.info}\n\n`;

  if (analysisId) {
    body += `**View full report**: [AutoRev Dashboard](https://autorev.servicevision.io/results/${analysisId})\n\n`;
  }

  body += `### What's Included\n\n`;
  body += `This PR adds a markdown file with:\n`;
  body += `- Executive summary with risk assessment\n`;
  body += `- Severity breakdown and statistics\n`;
  body += `- Detailed findings with recommendations\n`;
  body += `- Suggested fixes where applicable\n`;
  body += `- Prioritized action items\n\n`;

  body += `### Next Steps\n\n`;
  body += `1. Review the report file in this PR\n`;
  body += `2. Merge this PR to keep a permanent record in your repository\n`;
  body += `3. Create issues for high-priority findings\n`;
  body += `4. Track progress on addressing code quality issues\n\n`;

  body += `---\n`;
  body += `*Generated by [AutoRev Code Review](https://autorev.servicevision.io)*\n`;

  return body;
}

/**
 * Calculate statistics from findings
 */
function calculateStats(findings: any[]): Record<string, number> {
  const stats: Record<string, number> = {
    critical: 0,
    high: 0,
    medium: 0,
    low: 0,
    info: 0,
  };

  findings.forEach((finding) => {
    const severity = finding.severity?.toLowerCase() || 'info';
    stats[severity] = (stats[severity] || 0) + 1;
  });

  return stats;
}

function getSeverityIcon(severity: string): string {
  const icons: Record<string, string> = {
    critical: 'ðŸ”´',
    high: 'ðŸŸ ',
    medium: 'ðŸŸ¡',
    low: 'ðŸ”µ',
    info: 'âšª',
  };
  return icons[severity.toLowerCase()] || 'âšª';
}
